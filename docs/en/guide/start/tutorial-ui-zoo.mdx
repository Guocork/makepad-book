# Tutorial: UI Zoo

**You will need to build an modified version of UI zoo example from makepad. This tutorial will lead you get deep into makepad step by step. You could find the code [here](https://github.com/acyanbird/makepad-start). The code for each section in a separate git branch. This makes it possible to see the intermediate state after each section.**  

## Set up your project

To build the Makepad crates you first need to install Rust. https://www.rust-lang.org/tools/install  
We recommend that you build Makepad using the nightly Rust toolchain.

```bash
rustup install nightly
rustup default nightly
```

Use `cargo new makepad_book_ui_zoo` to create a crate.

```bash
cargo new makepad_book_ui_zoo
```

Add the `makepad-widgets` library dependency in `Cargo.toml`. Makepad is using 2021 version right now, so please change `edition = "2021"`.


```toml
[package]
name = "makepad_book_ui_zoo"
version = "0.1.0"
edition = "2021"

[dependencies]
# use rik branch，because it is the active development branch
makepad-widgets = { git = "https://github.com/makepad/makepad", branch = "rik" }
```

Then create `lib.rs` and `app.rs` files under src.

Your directory structure should look like this:

```plaintext
simple/
├── Cargo.lock
├── Cargo.toml
├── src
│   ├── app.rs
│   ├── lib.rs
│   └── main.rs

```

## Create basic window

Then let's complete our code in the `app.rs` module. 

Let's start by defining the overall component structure:

```rust
use makepad_widgets::*; // Import Makepad Widgets package

// Define live_design macro for declaring UI components and layout
live_design! {
    // import Makepad theme and shaders, and widgets
    use link::theme::*;
    use link::shaders::*;
    use link::widgets::*;
    App = {{App}} {
        ui: <Window> { }
        }
    }


// Define App struct containing UI and counter
#[derive(Live, LiveHook)]
pub struct App {
    #[live]
    ui: WidgetRef // UI component reference
}

// Implement LiveRegister trait for registering live design
impl LiveRegister for App {
    fn live_register(cx: &mut Cx) {
        // Register Makepad Widgets' live design
        makepad_widgets::live_design(cx);
    }
}

// Implement AppMain trait for handling events
impl AppMain for App {
    fn handle_event(&mut self, cx: &mut Cx, event: &Event) {
        // Handle UI events
        self.ui.handle_event(cx, event, &mut Scope::empty());
    }
}

// Define application entry point
app_main!(App);
```

Add the following code to `lib.rs`:

```rust
pub mod app;
```

Add the following code to call app_main() in main file:

```rust
fn main() {
    makepad_start::app::app_main();
}
```  
Run this project by
`cargo run`

You could see the output:

![basic view](./basic-view.png)  

Let's explain the code structure, you don't need to understand them right now:

1. `live_design!`,The live_design! macro is used to declare UI components and layout. It's part of the Live system we discussed earlier, implementing Live DSL using Rust macros to enable runtime UI modifications.
2. `app_main!(App)`defines the application entry point. Since Makepad needs to support cross-platform applications (including Web/iOS/Android/MacOS/Windows/Linux), the `app_main!` macro internally includes entry point code for various platforms, hence using a macro rather than a simple `main` function.
3. The Rust struct `App` uses the `derive(Live, LiveHook)` derive macro, automatically implementing two Live system-related traits for `App`: `Live` and `LiveHook`.
    - The `ui` field of type `WidgetRef` can be thought of as `dyn Widget`, representing UI controls that implement the `Widget` trait. These controls can be updated at runtime, marked with the #[live] attribute, which automatically implements certain derive macros, like creating `LiveId` for the field and calling `LiveHook` methods.
    - The `counter` field belongs to business logic, used for counting, so it's marked with the `#[rust]` attribute, telling the Live system it belongs to Rust's domain rather than UI controls and doesn't participate in runtime updates.
    - The `Live` and `LiveHook` traits are related to Makepad controls' Live lifecycle, which we'll discuss in detail later.
4. The `LiveRegister` trait is used to register `App` with the Live system.
5. The `AppMain` trait defines the `handle_event` method for passing various events to the UI tree, including mouse, timer, or scroll events.
    - This trait object is actually called in `app_main!`, making it part of the program entry point.
    - Internally, `ui`'s `handle_event` takes parameters `cx`/`event` for context information and events, while `Scope` is used for component state sharing, with `Scope::empty()` currently representing no shared state.

## Change background color and title

We can change the background color to the window by simply define color inside draw_bg field.  

### Background Color
There are several way to present color. For color using `vec3()`, the range is 0 and 1 instead of 0 to 255. For example, you can convert the color #970707 to vec3 form. #970707 is a dark red, and its RGB values are (151, 7, 7). By converting these values to floating-point numbers between 0 and 1, you can get vec3(0.592, 0.027, 0.027).

```rust
live_design! {
    // import Makepad theme and shaders, and widgets
    use link::theme::*;
    use link::shaders::*;
    use link::widgets::*;
    App = {{App}} {
        ui: <Window> {
            show_bg: true,
            draw_bg: {
                color: #970707    // dark red
                // color: vec3(0.592, 0.027, 0.027) // dark red as above
                // color: vec3(1, 1, 0) // yellow
                // color: #000 // black
                }
...
        }
    }
}
```
![darkred-bg](./darkred_bg.png)  
Try to change whatever color you want by yourself!  

And the [code](https://github.com/acyanbird/makepad-start/tree/01-basic-window) is available.

## Title 

The window section sets the window's title to "Makepad UI zoo".   
Following that is the caption_bar section, which defines a caption bar. visible: true indicates that the caption bar is visible, and `margin: {left: -500}` sets the left margin of the caption bar. You can change the value to move the position of the caption bar label.
Finally, caption_label defines the label within the caption bar, with its text content set to "Makepad book UI Zoo caption bar".

```rust
ui: <Window> {
            show_bg: true,
            draw_bg: {
                // color: #970707    // dark red
                // color: vec3(0.592, 0.027, 0.027) // dark red as above
                // color: vec3(1, 1, 0) // yellow
                color: #000 // black
                }
            window: {
                title: "Makepad UI zoo"
            },
            caption_bar = {
                visible: true,
                margin: {left: -500},
                caption_label = { label = {text: "Makepad book UI Zoo caption bar"} },
            },
        }
```
![change title](./change_title.png)
And the [code](https://github.com/acyanbird/makepad-start/tree/02-change-title-and-color) is available.

## Text
From this section, we swtich the background color back to default for better display effect. Simply comment all the color field in draw_bg
```rust
            draw_bg: {
                // color: #970707    // dark red
                // color: vec3(0.592, 0.027, 0.027) // dark red as above
                // color: vec3(1, 1, 0) // yellow
                // color: #000 // black
                }
``` 
Let's try to write some text inside this application~ But first, we need to define a child component body inside window:
```rust
            caption_bar = {
                visible: true,
                margin: {left: -500},
                caption_label = { label = {text: "Makepad book UI Zoo caption bar"} },
            },

            body = <View> {
                width: Fill, height: Fill,
                flow: Down, //child components will be arranged vertically
                spacing: 10.,   //spacing between child components
                margin: 0.,     //margin around the component
            }
```
This View component which provided by makepad will be called body in our appliation. It takes up the full width and height of its parent container. It arranges its child components vertically, with a spacing of 10 units between them. The margin: 0. property ensures that there is no extra space around the body component itself.  
Then the text itself can also be declared above of ui
```rust
    ZooTitle = <View> { // Define ZooTitle component inheriting from View
        width: Fill,    // Fill width
        height: Fit,    // Fit height 
        margin: 10.0,
        title = <H2> {
            text: "Makepad UI Zoo"
        }
    }
    ...
    App = {{App}} {
        ...
```
Then we can set the text component independently above ui:
```rust
live_design! {
    // import Makepad theme and shaders, and widgets
    use link::theme::*;
    use link::shaders::*;
    use link::widgets::*;

    ZooTitle = <View> { // Define ZooTitle component inheriting from View
        width: Fill,    // Fill width
        height: Fit,    // Fit height 
        margin: 10.0,
        title = <H2> {
            text: "Makepad UI Zoo"
        }
    }
    ...
```
Remind from previous sections, `width: Fill` means it will fill the parent component's width, `height: Fit` will set component height depends on its height. H2 component using markdown grammar to set the size of the text. 

Then combine it together:
```rust
            body = <View> {
                width: Fill, height: Fill,
                flow: Down, //child components will be arranged vertically
                spacing: 10.,   //spacing between child components
                margin: 0.,     //margin around the component

                <ZooTitle> {}
```
A title and description is needed for every group of components, let's define them now and reuse them in the future.
```rust
    ZooHeader = <View> {
        width: Fill, height: Fit,
        flow: Down,
        spacing: 10.,
        margin: {top: 0., right: 9, bottom: 0., left: 9}
        divider = <Hr> { }
        title = <H3> { }
    }

    ZooDesc = <P> { }
    ```
    You will see some familiar thing in HTML, and it works just like that! And we only need to cover the title field to the text we want to.
    
    ```rust
                    <ZooHeader> {
                    title = {text: "Intro"}
                    <ZooDesc> {
                        text: "Intro."
                    }
                    <View> {
                        width: Fill, height: Fit,
                        flow: Down,
                        <P> { text: "- Shader-based: what does that mean for how things work." }
                        <P> { text: "- Inheritance mechanisms in the DSL." }
                        <P> { text: "- Introduction to the layout system." }
                        <P> { text: "- Base theme parameters." }
                        <P> { text: "- Typographic system. Base font-size and contrast." }
                        <P> { text: "- Space constants to control denseness of the design." }
                        <P> { text: "- Transparency mechanism of the widgets. Nesting for structure." }
                    }
                }
```

![text](./text.png)
The code is available at [this branch](https://github.com/acyanbird/makepad-start/tree/03-add-text)

## Buttons and Typography

And then, let's try more component that provided by makepad! But first we need to add a scroll bar component. Or the things outside the window cannot be shown.

```rust
            body = <View> {
                width: Fill, height: Fill,
                flow: Down, //child components will be arranged vertically
                spacing: 10.,   //spacing between child components
                margin: 0.,     //margin around the component
                scroll_bars: <ScrollBars> {}
            }
```
Then we continue define buttons and styles as text.
```rust
                <ZooHeader> {
                    title = {text: "Control Heights & Text Baselines"}
                    <ZooDesc> {
                        text: "Control heights and text baselines"
                    }
                    <View> {
                        width: Fill, height: Fit,
                        align: { x: 0., y: 0.}
                        flow: Right,
                        spacing: (THEME_SPACE_2)
                        <P> { text: "TestLabel", width: Fit}
                        <Vr> {} 
                        <LinkLabel> { text: "TestButton", width: Fit}
                        <CheckBox> { text: "TestButton"}
                        <CheckBoxToggle> { text: "TestButton"}
                        <ButtonFlat> { text: "TestButton"}
                        <Button> { text: "TestButton"}
                        <TextInput> { text: "TestButton"}
                        <DropDown> { }
                        <Slider> { text: "TestButton"}
                        <SliderBig> { text: "TestButton"}
                    }
                }

                <ZooHeader> {
                    title = {text: "Typography"}
                    <ZooDesc> {
                        text: "Typography."
                    }
                    <View> {
                        width: Fill, height: Fit,
                        flow: Down,

                        <H1> { text: "H1 headline" }
                        <H1italic> { text: "H1 italic headline" }
                        <H2> { text: "H2 headline" }
                        <H2italic> { text: "H2 italic headline" }
                        <H3> { text: "H3 headline" }
                        <H3italic> { text: "H3 italic headline" }
                        <H4> { text: "H4 headline" }
                        <H4italic> { text: "H4 italic headline" }
                        <P> { text: "P copy text" }
                        <Pitalic> { text: "P italic copy text" }
                        <Pbold> { text: "P bold copy text" }
                        <Pbolditalic> { text: "P bold italic copy text" }
                    }
                }
```
In this case, flow for buttons is right so you could see these buttons are align in row. THEME_SPACE_2 is a constant. It is defined in the theme_mobile_light.rs file from makepad widget. 
![buttons&typo](./buttons.png)

Code is available at [branch 04](https://github.com/acyanbird/makepad-start/tree/04-buttons-and-typography)

## More Views
In this section we will show complex combination of views. As usual, we define a component that would show a color block. It would be a little bit different from classic view. The rounded view would have round corner instead of right angle:

```rust
    // define color of background container
    COLOR_CONTAINER = (THEME_COLOR_D_1)

    // define colors for demo blocks
    DEMO_COLOR_1 = #8f0
    DEMO_COLOR_2 = #0f8
    DEMO_COLOR_3 = #80f

    ZooBlock = <RoundedView> {
        width: 50., height: 50.
        margin: 0.,
        spacing: 0.,

        show_bg: true;
        draw_bg: {
            // return color based on position
            fn get_color(self) -> vec4 {
                return mix(self.color, self.color*0.5, self.pos.y);
            }
            // a float value for the corner radius
            radius: (THEME_CONTAINER_CORNER_RADIUS)
        }
    }
```
What will `get_color` do? Well, This function provides a gradient effect to the color block. This mix function will return color base on position y, and it is a range from 0 to 1 from up to bottom. The color block will transition from self.color to self.color * 0.5 (a darker color), determined by self.pos.y. For example, if we set self.pos.y to 0, the block will be self.color.  

Let's define a `ZooHeader` component that includes various nested views and descriptive components. You can adjust the flow, padding, spacing, and other fields to see how the nested views are rendered.
```rust
                <ZooHeader> {
                    title = {text: "<View>" }
                    <ZooDesc> {text:"This is a gray view with flow set to Right\nTo show the extend, the background has been enabled using show_bg and a gray pixelshader has been provided to draw_bg."}
                    <View> {
                        height: Fit
                        flow: Right,
                        show_bg: true,
                        draw_bg: { color: (COLOR_CONTAINER) }
                        padding: 10.
                        spacing: 10.
                        <ZooBlock> {draw_bg:{color: (DEMO_COLOR_1)}}
                        <ZooBlock> {draw_bg:{color: (DEMO_COLOR_2)}}
                        <ZooBlock> {draw_bg:{color: (DEMO_COLOR_3)}}
                    }

                    <ZooDesc> {text:"This utlizes a <Filler> to separate items."}
                    <View> {
                        height: Fit
                        flow: Right,
                        show_bg: true,
                        draw_bg: { color: (COLOR_CONTAINER) }
                        padding: 10.
                        spacing: 10.
                        <ZooBlock> {draw_bg:{color: (DEMO_COLOR_1)}}
                        <Filler> {} // placeholder
                        <ZooBlock> {draw_bg:{color: (DEMO_COLOR_2)}}
                        <ZooBlock> {draw_bg:{color: (DEMO_COLOR_3)}}
                    }
                    
                    <ZooDesc> {text:"This view is bigger on the inside"}
                    <View> {
                        width: 150, height: 150,
                        flow: Right,
                        padding: 10.
                        spacing: 10.

                        show_bg: true,
                        draw_bg: { color: (COLOR_CONTAINER) }
                        scroll_bars: <ScrollBars> {}

                        <View> {
                            width: Fit, height: Fit,
                            flow: Down,
                            show_bg: false,
                            spacing: 10
                            <ZooBlock> {draw_bg:{color: (DEMO_COLOR_1)}}
                            <ZooBlock> {draw_bg:{color: (DEMO_COLOR_2)}}
                            <ZooBlock> {draw_bg:{color: (DEMO_COLOR_3)}}
                            <ZooBlock> {draw_bg:{color: (DEMO_COLOR_2)}}
                        }

                        <View> {
                            width: Fit, height: Fit,
                            flow: Down,
                            show_bg: false,
                            spacing: 10
                            <ZooBlock> {draw_bg:{color: (DEMO_COLOR_1)}}
                            <ZooBlock> {draw_bg:{color: (DEMO_COLOR_2)}}
                            <ZooBlock> {draw_bg:{color: (DEMO_COLOR_3)}}
                            <ZooBlock> {draw_bg:{color: (DEMO_COLOR_2)}}
                        }

                        <View> {
                            width: Fit, height: Fit,
                            flow: Down,
                            show_bg: false,
                            <ZooBlock> {draw_bg:{color: (DEMO_COLOR_1)}}
                            <ZooBlock> {draw_bg:{color: (DEMO_COLOR_2)}}
                            <ZooBlock> {draw_bg:{color: (DEMO_COLOR_3)}}
                            <ZooBlock> {draw_bg:{color: (DEMO_COLOR_2)}}
                        }

                        <View> {
                            width: Fit, height: Fit,
                            flow: Down,
                            show_bg: false,
                            spacing: 10
                            <ZooBlock> {draw_bg:{color: (DEMO_COLOR_1)}}
                            <ZooBlock> {draw_bg:{color: (DEMO_COLOR_2)}}
                            <ZooBlock> {draw_bg:{color: (DEMO_COLOR_3)}}
                            <ZooBlock> {draw_bg:{color: (DEMO_COLOR_2)}}
                        }

                        <View> {
                            width: Fit, height: Fit,
                            flow: Down,
                            show_bg: false,
                            spacing: 10
                            <ZooBlock> {draw_bg:{color: (DEMO_COLOR_1)}}
                            <ZooBlock> {draw_bg:{color: (DEMO_COLOR_2)}}
                            <ZooBlock> {draw_bg:{color: (DEMO_COLOR_3)}}
                        }
                    }
                }
```

![nested-views](./nested-views.png)
The bigger view inside smaller view also use scroll bar component to move.

The code is available [here](https://github.com/acyanbird/makepad-start/tree/05-view).

## Interaction
We need to make the interface dynamic, so it can respond properly to user input. That way, we can fully utilize all the features of Makepad. Now, let's introduce the text input box and see how it works with the handle event to give dynamic feedback.

### Text input

```rust
pub struct App {
    #[live]
    ui: WidgetRef, // UI component reference
    #[rust] counter: usize  // use rust instead of live for counter
}

// Implement LiveRegister trait for registering live design
impl LiveRegister for App {
    fn live_register(cx: &mut Cx) {
        // Register Makepad Widgets' live design
        makepad_widgets::live_design(cx);
    }
}

impl MatchEvent for App{
    fn handle_actions(&mut self, cx: &mut Cx, actions:&Actions){
    if let Some(txt) = self.ui.text_input(id!(simpletextinput)).changed(&actions){  // when text input changes
        log!("TEXTBOX CHANGED {}", self.counter);   // output to console
        self.counter += 1;
        let lbl = self.ui.label(id!(simpletextinput_outputbox));
        lbl.set_text(cx,&format!("{} {}" , self.counter, txt));
    }
}
}

// Implement AppMain trait for handling events
impl AppMain for App {
    fn handle_event(&mut self, cx: &mut Cx, event: &Event) {
        self.match_event(cx, event);    
        self.ui.handle_event(cx, event, &mut Scope::empty());
    }
}
```

`#[rust] counter: usize` The counter is set to count the time of user input. `[rust]` Means the counter is defined by rust no live system. Because there will be more events we need to handle in future, put them into MatchEvent. This event logs the change, increments a counter. And updates a label with the new text and the counter value whenever the text in the input field changes. The ID, or we can call the named is used to located specific component.

Let's define textinput boxes above:
```rust
                <ZooHeader> {
                    title = {text:"<TextInput> with interaction"}
                    padding: 10.
                        <View> {
                            height: Fit, width: Fill,
                            spacing: (THEME_SPACE_2),
                            textalreadyfilled = <TextInput> {
                                text: "text here"
                            }
                            simpletextinput = <TextInput> { // simpletextinput is the id
                                width: Fill,
                             empty_message: "input" }
                             // chanagble output box
                            simpletextinput_outputbox = <P> {
                                text: "Output"
                            }
                        }
                }
```
Two text input boxes are defined, and the change of second one will also change the label aside. The label will show the content of box and counter variable which count user input. Take these two code snippets together, you will know how event works. 

![text](./interaction-text.png)

### Buttons

We could also try event in button component. Not only the text but also image is supported by using  `<ButtonIcon>` instead of common `<Button>`. But we define a `<ZooGroup>` at first to group up component:

```rust
    ZooGroup = <RoundedView> {
        height: Fit, width: Fill,
        flow: Right,
        align: { x: 0.0, y: 0.5},
        margin: 0.,
        show_bg: false;
        draw_bg: { color: (COLOR_CONTAINER) }
    }
```

And add these buttons. We use image by placing the svg file in the resources folder, which is at the same level as the src folder. You could find the image [here](https://github.com/acyanbird/makepad-start/blob/06-interaction/resources/Icon_Favorite.svg). The image could be colored by using color field. Also flat button is introduced, it does not have a prominent border and background color. 

```rust
                <ZooHeader> {
                    title = {text:"<Button>"}
                    <ZooDesc> {text:"A small clickable region"}
                    <ZooGroup> {
                        flow: Down,
                        width: Fill, height: Fit,
                        align: { x: 0.0, y: 0.5 }
                        spacing: 10.,

                        <H4> { text: "Default"}
                        <Label> { text: "<Button>"}
                        basicbutton = <Button> { text: "I can be clicked" }

                        <H4> { text: "Button with an icon"}
                        <Label> { text: "<ButtonIcon>"}
                        iconbutton = <ButtonIcon> {
                            draw_icon: {
                                color: #ff0,
                                svg_file: dep("crate://self/resources/Icon_Favorite.svg"),
                            }
                            text: "I can have a icon!"
                        }

                        <H4> { text: "Flat Mode"}
                        <Label> { text: "<ButtonFlat>"}
                        <View> {
                            flow: Right,
                            align: { x: 0., y: 0.5 }
                            width: Fill, height: Fit,
                            <ButtonFlat> {
                                draw_icon: {
                                    color: #f00,
                                    svg_file: dep("crate://self/resources/Icon_Favorite.svg"),
                                }
                                text: "I can have a lovely icon!"
                            }

                            <ButtonFlat> {
                                draw_icon: {
                                    svg_file: dep("crate://self/resources/Icon_Favorite.svg"),
                                }
                            }

                            <ButtonFlat> {
                                flow: Down,
                                icon_walk: { width: 15. }
                                draw_icon: {
                                    svg_file: dep("crate://self/resources/Icon_Favorite.svg"),
                                }
                                text: "Vertical Layout"
                            }
                        }
                    }
                }
```

Now let's handle the event. 

```rust
    if let Some(txt) = self.ui.text_input(id!(simpletextinput)).changed(&actions){  // when text input changes
        log!("TEXTBOX CHANGED {}", self.counter);   // output to console
        self.counter += 1;
        let lbl = self.ui.label(id!(simpletextinput_outputbox));
        lbl.set_text(cx,&format!("{} {}" , self.counter, txt));
    }

    if self.ui.button(id!(basicbutton)).clicked(&actions) {
        log!("BASIC BUTTON CLICKED {}", self.counter);
        self.counter += 1;
        let btn = self.ui.button(id!(basicbutton));
        btn.set_text(cx,&format!("Clicky clicky! {}", self.counter));
    }

    if self.ui.button(id!(iconbutton)).clicked(&actions) {
        log!("ICON BUTTON CLICKED {}", self.counter);
        self.counter += 1;
        let btn = self.ui.button(id!(iconbutton));
        btn.set_text(cx,&format!("Icon button clicked: {}", self.counter));
    }
```
The counter is used to count the total click times, it is shared by all the buttons and text box. If you want to set counter seperatly, you could use different variable.


![b](./interact-buttons.png)

Makepad can treat with hover too. Let's see how the text color changed when cursor above the button:

```rust
                            <H4> { text: "Hover"}
                            styledbutton = <Button> {
                                draw_bg: {
                                    fn pixel(self) -> vec4 {
                                        return (THEME_COLOR_MAKEPAD) + self.pressed * vec4(1., 1., 1., 1.)
                                    }
                                }
                                draw_text: {
                                    fn get_color(self) -> vec4 {
                                        return (THEME_COLOR_U_5) - vec4(0., 0.1, 0.4, 0.) * self.hover - self.pressed * vec4(1., 1., 1., 0.);
                                    }
                                }
                                text: "I can be styled!"
                            }
```

No need to change the match event for this one. `self.hover` is a bool value that make text color changed when the cursor is above. Also when the button is clicked, the background color and text color also changed.

![hover](./hover.png)

It's a bit uncleared but the text color change to orange instead of white when it is hover.

