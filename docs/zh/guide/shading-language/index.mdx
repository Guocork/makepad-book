# Shader 基础概念

`Makepad Shader` 是自定义的 `MPSL` 着色语言。 MPSL 可以生成为 glsl 等着色语言。

> 推荐前置知识学习：GLSL 着色器入门教程 https://thebookofshaders.com/?lan=ch

## 什么是Shader

让我们先从一个简单的比喻开始理解什么是 shader。想象你是一个画家，面前有一块巨大的画布，这个画布被分成了数百万个小格子(像素)。

现在你有两个任务：

1. 决定每个形状的位置和大小（顶点着色器）
2. 决定每个格子应该填充什么颜色（像素/片元着色器）

```rust
// 一个最基础的 Makepad shader
MyFirstShader = {{MyFirstShader}} {
    // 1. 顶点着色器 - 处理位置
    fn vertex(self) -> vec4 {
        // 将形状放在正确的位置
        let position = self.geom_pos * self.rect_size + self.rect_pos;
        return self.camera_projection * vec4(position, 0.0, 1.0);
    }

    // 2. 片元着色器 - 处理颜色
    fn pixel(self) -> vec4 {
        // 给每个像素上色
        return vec4(1.0, 0.0, 0.0, 1.0); // 红色
    }
};
```

让我们可视化一下这个过程：

```plaintext
顶点着色阶段:                像素着色阶段:

   P1●─────●P2                 ░░░░░░░░
     │     │                   ░██████░
     │     │         =>        ░██████░
     │     │                   ░██████░
   P3●─────●P4                 ░░░░░░░░

 (确定形状位置)              (填充每个像素)
```

## GPU vs CPU 渲染的区别

为什么要用GPU渲染？让我们通过一个实例来理解。

假设要渲染一个 1000x1000 像素的区域：

```plaintext
CPU 渲染:
- 依次处理每个像素
- 100万个像素需要依次处理
- 类似于用一个画笔一点点填充

GPU 渲染:
- 大量像素并行处理
- 100万个像素可以同时处理
- 类似于用喷枪快速覆盖
```
视觉化表示:

```plaintext
CPU 渲染进度:              GPU 渲染进度:
█░░░░░░░░░  10%          ▒▒▒▒▒▒▒▒▒▒  100%
██░░░░░░░░  20%          (同时处理)
███░░░░░░░  30%
...
██████████  100%
```
本质上是为了提升性能，GPU 是一个专门用于图形渲染的硬件，它可以同时处理大量像素，因此比 CPU 更适合渲染图形。

## 坐标系统详解

在 Makepad 中，我们需要处理三种主要的坐标系统:

### `归一化设备坐标(NDC)`

[-1,1]范围，提供设备无关的标准化空间，确保渲染结果在不同分辨率下保持一致。

- 使用场景：当你需要进行设备无关的渲染或者处理3D变换时。
- 比如：3D渲染、视图裁剪、透视投影、跨设备一致性渲染等。

### `像素坐标`

实际屏幕像素，用于精确定位屏幕上的实际位置，直接对应物理显示设备。

- 使用场景：当你需要精确控制渲染目标在屏幕上的确切位置时。
- 比如：UI元素的精确定位、像素边框的绘制、文本渲染的对齐等。

### `UV 坐标`：

[0,1]范围的纹理坐标，用于纹理映射和参数化表面， 提供独立于分辨率的相对位置。

- 使用场景：当你需要处理纹理映射或者创建参数化的视觉效果时。
- 比如：纹理映射、渐变效果、UV动画、程序化纹理生成、参数化形状等。

### 代码和图示来理解坐标转换

```rust
让我们通过代码和图示来理解坐标转换:
fn vertex(self) -> vec4 {
    // 1. 几何坐标到像素坐标的映射
    let pixel_pos = self.geom_pos * self.rect_size + self.rect_pos;

    // 2. 像素坐标到 UV 坐标的映射
    self.uv = (pixel_pos - self.rect_pos) / self.rect_size;

    // 3. 像素坐标到 NDC 的映射
    let ndc = self.camera_projection * vec4(pixel_pos, 0.0, 1.0);

    return ndc;
}
```
坐标系统的可视化:

```plaintext
归一化设备坐标(NDC)      像素坐标            UV坐标
     (-1,1)            (0,0)              (0,0)
        ┃               ┃                   ┃
        ┃               ┃                   ┃
  ━━━━━━●━━━━━━   ━━━━━●━━━━━   ━━━━━━━●━━━━━━━
        ┃               ┃                   ┃
        ┃               ┃                   ┃
     (1,-1)         (width,            (1,1)
                    height)

坐标映射流程图:

像素坐标 (100, 100)            UV坐标 (0.5, 0.5)           NDC (0.0, 0.0)
    ┌──────────┐               ┌──────────┐               ┌──────────┐
    │(0,0)     │     ÷size     │(0,0)     │    *2-1       │(-1,1)    │
    │          │ ────────────► │          │ ────────────► │          │
    │   ●      │               │   ●      │               │   ●      │
    │          │               │          │               │          │
    │     (w,h)│               │     (1,1)│               │    (1,-1)│
    └──────────┘               └──────────┘               └──────────┘


需求判断：
┌────────────────────┐
│ 是否需要像素精度？    │
└─────────┬──────────┘
          │
    ┌─────┴─────┐
    │   Yes     │     No
    ▼           ▼
像素坐标     ┌──────────────┐
            | 是否需要纹理   |
            │   或渐变？    │
            └──────┬───────┘
                   │
              ┌────┴────┐
              │  Yes    │     No
              ▼         ▼
           UV坐标    NDC坐标

```
## 颜色与像素

在 Makepad 中，颜色使用 vec4 表示，包含 RGBA 四个通道:

```rust
fn pixel(self) -> vec4 {
    //---------- 红   绿   蓝   透明度
    return vec4(1.0, 0.0, 0.0, 1.0);
}
```
颜色混合示意:

```plaintext
基础颜色:           透明度混合:
Red   (1,0,0)      ██ 不透明 (alpha = 1.0)
Green (0,1,0)  +   ▒▒ 半透明 (alpha = 0.5)
Blue  (0,0,1)      ░░ 透明   (alpha = 0.0)
```

预乘Alpha的概念：

```rust
// 普通 RGBA
vec4(1.0, 0.0, 0.0, 0.5) // 半透明红色

// 预乘 Alpha (推荐)
vec4(0.5, 0.0, 0.0, 0.5) // RGB 通道已乘以 alpha
```
